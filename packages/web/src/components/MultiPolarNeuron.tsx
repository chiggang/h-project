/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Alain Sorazu (https://sketchfab.com/alainsorazu)
license: CC-BY-SA-4.0 (http://creativecommons.org/licenses/by-sa/4.0/)
source: https://sketchfab.com/3d-models/multipolar-neuron-6834b20a2bc6473d85737587a20ff84f
title: Multipolar neuron
*/

import * as THREE from 'three';
import React, {
  memo,
  useCallback,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import { useBVH, useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { RootState, useFrame, useThree } from '@react-three/fiber';
import { useTimeout } from '@mantine/hooks';
import { ENeuron } from '../enums/app.enum';
import { GLTFResult, IWindowMessage } from '../interfaces/app.interface';
import NeuronMesh from './NeuronMesh';

const color = new THREE.Color();

// export function MultiPolarNeuron(props: JSX.IntrinsicElements['group']) {
// export function MultiPolarNeuron(props: any) {
const MultiPolarNeuron: React.FC<any> = memo((props) => {
  // // NeuronControl SWR을 정의함
  // const {
  //   neuronControlMutate,
  //   modifySelectedIdMutate,
  //   modifySelectedMeshMutate,
  // } = useNeuronControlSWR();

  // const [glowNeuron, setGlowNeuron] = useState<boolean>(false);

  //
  // const [groupMouseOver, setGroupMouseOver] = useState<boolean>(false);

  // const { start, clear } = useTimeout(() => {
  //   setGlowNeuron(false);
  // }, 1000);

  //
  let groupMouseOver: boolean = false;

  const ref = useRef<THREE.Mesh>(null!);
  const ref2 = useRef<THREE.Mesh>(null!);
  const ref3 = useRef<THREE.Mesh>(null!);

  useBVH(ref);
  useBVH(ref2);
  useBVH(ref3);

  // const { nodes, materials } = useGLTF(
  //   '/gltf/multipolar_neuron/scene-transformed.glb',
  // ) as GLTFResult;

  const handleGroup_onPointerOver = () => {
    // setGroupMouseOver(true);
    groupMouseOver = true;
  };

  const handleGroup_onPointerLeave = () => {
    // setGroupMouseOver(false);
    groupMouseOver = false;
  };

  useFrame((state: RootState) => {
    const time = state.clock.getElapsedTime();
    // let newOpacity = 1 + Math.sin(state.clock.elapsedTime * 2) / 3;
    // (ref.current.material as THREE.MeshStandardMaterial).opacity = newOpacity;
    // (ref.current.material as THREE.MeshStandardMaterial).opacity = 0.3;
    // ref.current.scale.setScalar(
    //     hovered ? 1 + Math.sin(state.clock.elapsedTime * 10) / 50 : 1,
    //   );
    // (ref.current.material as THREE.MeshStandardMaterial).color.lerp(
    //   color.set(`rgb(5,150,${parseInt(t.toString())})`),
    //   0.5,
    // );
    /*
    // if (props.tag.id === neuronControlMutate?.selectedId) {
    if (ref.current === neuronControlMutate?.selectedMesh) {
      if (glowNeuron) {
        if (eventing) {
          return;
        } else {
          eventing = true;
        }

        console.log('on:', neuronControlMutate?.selectedMesh);
        //
        //   // (ref.current.material as THREE.MeshStandardMaterial).color.lerp(
        //   //   color.set(`rgb(255,255,255)`),
        //   //   1,
        //   // );
        //
        (
          neuronControlMutate?.selectedMesh
            .material as THREE.MeshStandardMaterial
        ).color.lerp(color.set(`rgb(255,255,255)`), 1);
      } else {
        console.log('off');
        //
        //   // (ref.current.material as THREE.MeshStandardMaterial).color.lerp(
        //   //   color.set('rgb(14,87,183)'),
        //   //   1,
        //   // );
        //   (
        //     neuronControlMutate?.selectedMesh
        //       .material as THREE.MeshStandardMaterial
        //   ).color.lerp(color.set('rgb(14,87,183)'), 1);
        //
        eventing = false;

        (async () => {
          await modifySelectedMeshMutate(null);
        })();
      }
    }
    */

    let tmpColor: string = '';
    let tmpOpacity: number = 0.5;

    switch (props.tag.category) {
      case ENeuron.NONE:
        tmpColor = 'rgb(39,39,39)';
        tmpOpacity = 0.1;
        break;

      case ENeuron.INSPIRATION:
        tmpColor = 'rgb(27,80,151)';
        break;

      case ENeuron.RESEARCH:
        tmpColor = 'rgb(139,153,89)';
        break;

      case ENeuron.POSSIBILITY:
        tmpColor = 'rgb(186,100,121)';
        break;

      default:
        tmpColor = 'rgb(39,39,39)';
        tmpOpacity = 0.1;
        break;
    }

    if (groupMouseOver) {
      // tmpColor = 'rgb(255,255,255)';
      // tmpOpacity = 0.5;
      tmpOpacity = Math.abs(Math.sin(time / 0.7));
    }

    (ref.current.material as THREE.MeshStandardMaterial).color.lerp(
      color.set(tmpColor),
      1,
    );

    (ref.current.material as THREE.MeshStandardMaterial).opacity = tmpOpacity;

    ref.current.scale.x =
      ref.current.scale.y =
      ref.current.scale.z =
        THREE.MathUtils.lerp(
          ref.current.scale.z,
          groupMouseOver ? 1.1 : 1,
          0.05,
        );

    // (ref.current.material as THREE.MeshStandardMaterial).needsUpdate = true;
  });

  useEffect(() => {
    // console.log('> props:', props.tag);
    // let tmpColor: string = '';
    //
    // switch (props.tag.category) {
    //   case ENeuron.NONE:
    //     tmpColor = 'rgb(39,39,39)';
    //     break;
    //
    //   case ENeuron.INSPIRATION:
    //     tmpColor = 'rgb(27,80,151)';
    //     break;
    //
    //   case ENeuron.RESEARCH:
    //     tmpColor = 'rgb(83,102,15)';
    //     break;
    //
    //   case ENeuron.POSSIBILITY:
    //     tmpColor = 'rgb(167,21,56)';
    //     break;
    //
    //   default:
    //     tmpColor = 'rgb(39,39,39)';
    //     break;
    // }
    //
    // (ref.current.material as THREE.MeshStandardMaterial).color.lerp(
    //   color.set(tmpColor),
    //   1,
    // );
    //
    // (ref.current.material as THREE.MeshStandardMaterial).opacity = 0.1;
  }, []);

  // useEffect(() => {
  //   if (
  //     !neuronControlMutate?.selectedId ||
  //     props.tag.id !== neuronControlMutate?.selectedId
  //   ) {
  //     return;
  //   }
  //
  //   // (async () => {
  //   //   await modifySelectedMeshMutate(ref.current);
  //   // })();
  //   //
  //   // setGlowNeuron(true);
  //   // start();
  //
  //   // console.log('> neuronControlMutate:', neuronControlMutate);
  //   // console.log('> neuronControlMutate:', ref.current);
  // }, [neuronControlMutate?.selectedId]);

  return (
    <group
      {...props}
      dispose={null}
      name={`group-neuron-${props.tag.id}`}
      onClick={(event: any) => {
        event.stopPropagation();

        // console.log(event);
        console.log(event.eventObject.name);

        const objectWorldPosition: THREE.Vector3 = new THREE.Vector3();
        event.eventObject.getWorldPosition(objectWorldPosition);

        // 윈도우 메시지를 보냄
        window.postMessage(
          {
            type: '',
            command: 'reset-camera',
            data: {
              x: objectWorldPosition.x,
              y: objectWorldPosition.y,
              z: objectWorldPosition.z + 5,
            },
          } as IWindowMessage,
          '*',
        );
      }}
    >
      <group rotation={[-Math.PI / 2, 0, 0]} scale={0.05}>
        <group rotation={[Math.PI / 2, 0, 0]}>
          <group position={[0.1, 8.39, 0.3]} scale={0.26}>
            <mesh
              ref={ref2}
              geometry={props.gltf.nodes.Object_4.geometry.clone()}
              material={props.gltf.materials.Nucleus.clone()}
            >
              {/*<meshStandardMaterial*/}
              {/*  color="#FFFFFF"*/}
              {/*  metalness={1}*/}
              {/*  roughness={0.1}*/}
              {/*/>*/}
            </mesh>
            <mesh
              ref={ref}
              geometry={props.gltf.nodes.Object_5.geometry.clone()}
              material={props.gltf.materials.Neuron.clone()}
              // material-metalness={1}
              onPointerOver={handleGroup_onPointerOver}
              onPointerLeave={handleGroup_onPointerLeave}
            />
            <mesh
              ref={ref3}
              geometry={props.gltf.nodes.Object_6.geometry.clone()}
              material={props.gltf.materials.Light.clone()}
            />
          </group>
        </group>
      </group>
    </group>
  );
});

// useGLTF.preload('/gltf/multipolar_neuron/scene-transformed.glb');

export default MultiPolarNeuron;
